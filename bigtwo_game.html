<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>大老二 - 賭神回歸版</title>
    <style>
        :root { --green: #1a472a; --card-bg: #fff; --active-gold: #ffeb3b; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body { background-color: #000; margin: 0; width: 100vw; height: 100vh; overflow: hidden; display: flex; justify-content: center; align-items: center; font-family: sans-serif; }

        /* 強制橫屏旋轉邏輯 */
        @media screen and (orientation: portrait) {
            #game-wrapper { width: 100vh; height: 100vw; transform: rotate(90deg); transform-origin: center; }
        }
        @media screen and (orientation: landscape) {
            #game-wrapper { width: 100vw; height: 100vh; }
        }

        #game-wrapper {
            background-color: var(--green);
            display: grid;
            grid-template-areas: "p2 p2 p2" "p1 table p3" "p0 p0 p0";
            grid-template-columns: 90px 1fr 90px;
            grid-template-rows: 80px 1fr 150px;
            position: relative;
        }

        .slot { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #p0 { grid-area: p0; z-index: 100; } 
        #table { grid-area: table; position: relative; border-radius: 50%; border: 2px dashed rgba(255,255,255,0.1); margin: 10px; }

        /* 卡片設計 - 強化玩家牌面 */
        .card-row { display: flex; justify-content: center; width: 100%; height: 90px; align-items: flex-end; }
        
        .card { 
            width: 58px; height: 85px; 
            background: var(--card-bg); color: black; border-radius: 6px; 
            margin-left: -30px; 
            border: 1.5px solid #333; 
            display: flex; flex-direction: column; 
            padding: 5px;
            position: relative; transition: all 0.15s ease-out; 
            box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
            user-select: none;
        }
        .card:first-child { margin-left: 0; }
        
        /* 牌面字體強化 */
        .card .val { font-size: 22px; font-weight: 900; line-height: 1; align-self: flex-start; }
        .card .suit { font-size: 18px; align-self: flex-start; margin-top: -2px; }

        .card.red { color: #e31a1c; }
        .card.npc-card { background: #0d2a18; color: transparent; border-color: #222; width: 35px; height: 50px; margin-left: -25px;}

        /* 選中後的強化顯示 */
        .card.selected { 
            transform: translateY(-40px) scale(1.3);
            z-index: 500; 
            border: 3px solid #2196F3;
            box-shadow: 0 10px 25px rgba(0,0,0,0.7);
        }

        /* 側邊圓形按鈕 */
        .side-controls {
            position: absolute; right: 20px; bottom: 155px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .side-controls button {
            width: 75px; height: 75px; border-radius: 50%; border: none;
            background: #fff; font-weight: bold; font-size: 18px; color: #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        .side-controls button:active { transform: scale(0.9); background: #ddd; }
        .side-controls button:disabled { opacity: 0.3; background: #666; }

        #last-play-area { display: flex; gap: 5px; min-height: 85px; justify-content: center; align-items: center; }
        .msg-log { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 15px; text-shadow: 1px 1px 3px #000; text-align: center;}
        
        .name-tag { background: rgba(0,0,0,0.7); padding: 3px 12px; border-radius: 12px; font-size: 13px; margin-bottom: 5px; color: #eee;}
        .active { color: var(--active-gold); border: 2px solid var(--active-gold); font-weight: bold; box-shadow: 0 0 10px var(--active-gold); }
        
        #new-game-btn { position: absolute; left: 15px; top: 15px; z-index: 200; padding: 8px 15px; border-radius: 20px; border: none; background: #fff; font-size: 13px; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <button id="new-game-btn" onclick="initGame()">新局</button>

    <div class="slot" id="p2"><div class="name-tag" id="name-2"></div><div id="hand-2" class="card-row"></div></div>
    <div class="slot" id="p1"><div class="name-tag" id="name-1"></div><div id="hand-1" class="card-row"></div></div>
    
    <div id="table">
        <div class="msg-log" id="game-msg">載入中...</div>
        <div id="last-play-area"></div>
    </div>
    
    <div class="slot" id="p3"><div class="name-tag" id="name-3"></div><div id="hand-3" class="card-row"></div></div>
    
    <div class="slot" id="p0">
        <div id="hand-0" class="card-row"></div>
        <div class="name-tag" id="name-0">玩家 (你)</div>
    </div>

    <div class="side-controls">
        <button id="btn-play" onclick="playerAction()">出牌</button>
        <button id="btn-pass" onclick="playerPass()">過</button>
    </div>
</div>

<script>
const SUITS = ['♦', '♣', '♥', '♠']; 
const VALUES = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
// 擴充 NPC 詞庫
const NPC_NAMES = [
    "賭神高進", "少年賭聖", "陳小刀", "大軍", "龍五", "海棠小姐", 
    "三叔", "賭俠", "特異功能星仔", "地獄騎士", "川島芳子", 
    "賭王陳金城", "仇笑痴", "阿漆", "達聞西"
];

let deck = [], hands = [[], [], [], []], names = [];
let currentTurn = 0, lastPlay = null, passCount = 0, isFirstTurn = true;

function initGame() {
    // 隨機產生 NPC 名稱
    names = ["你"];
    let pool = [...NPC_NAMES];
    for(let i=0; i<3; i++) {
        let randIdx = Math.floor(Math.random() * pool.length);
        names.push(pool.splice(randIdx, 1)[0]);
    }
    for(let i=0; i<4; i++) document.getElementById(`name-${i}`).innerText = names[i];

    // 初始化牌組
    deck = [];
    for (let v=0; v<13; v++) {
        for (let s=0; s<4; s++) {
            deck.push({v, s, label: VALUES[v], suit: SUITS[s]});
        }
    }
    // 洗牌
    deck.sort(() => Math.random() - 0.5);
    
    // 發牌與排序 (點數優先，花色次之)
    for (let i=0; i<4; i++) {
        hands[i] = deck.splice(0, 13).sort((a, b) => (a.v * 4 + a.s) - (b.v * 4 + b.s));
    }

    // 判斷方塊三由誰開始
    currentTurn = hands.findIndex(h => h.some(c => c.v === 0 && c.s === 0));
    lastPlay = null; 
    passCount = 0; 
    isFirstTurn = true;
    
    updateUI();
    log(`${names[currentTurn]} 擁有方塊三，請開牌`);
    if (currentTurn !== 0) setTimeout(npcTurn, 1200);
}

function updateUI() {
    for (let i = 0; i < 4; i++) {
        const container = document.getElementById(`hand-${i}`);
        container.innerHTML = '';
        hands[i].forEach((card, idx) => {
            const div = document.createElement('div');
            div.className = `card ${i===0?'':'npc-card'} ${(card.s===0||card.s===2)?'red':''}`;
            div.innerHTML = `<span class="val">${card.label}</span><span class="suit">${card.suit}</span>`;
            if (i === 0) {
                div.dataset.idx = idx;
                div.onclick = () => { 
                    div.classList.toggle('selected');
                    if(navigator.vibrate) navigator.vibrate(12);
                };
            }
            container.appendChild(div);
        });
        document.getElementById(`name-${i}`).className = `name-tag ${currentTurn === i ? 'active' : ''}`;
    }
    
    const lastArea = document.getElementById('last-play-area');
    lastArea.innerHTML = '';
    if (lastPlay) {
        lastPlay.cards.forEach(c => {
            lastArea.innerHTML += `<div class="card ${(c.s===0||c.s===2)?'red':''}">
                <span class="val">${c.label}</span><span class="suit">${c.suit}</span>
            </div>`;
        });
    }
    
    document.getElementById('btn-play').disabled = (currentTurn !== 0);
    document.getElementById('btn-pass').disabled = (currentTurn !== 0 || !lastPlay || isFirstTurn);
}

function log(m) { document.getElementById('game-msg').innerText = m; }

// 規則與 AI 部分
function getPattern(cards) {
    if (cards.length === 0) return null;
    cards.sort((a, b) => (a.v * 4 + a.s) - (b.v * 4 + b.s));
    const len = cards.length;
    const maxW = cards[len-1].v * 4 + cards[len-1].s;

    if (len === 1) return { type: 1, weight: maxW };
    if (len === 2 && cards[0].v === cards[1].v) return { type: 2, weight: maxW };
    if (len === 5) {
        const counts = {}; cards.forEach(c => counts[c.v] = (counts[c.v] || 0) + 1);
        const v = Object.values(counts);
        const isFlush = cards.every(c => c.s === cards[0].s);
        const isStraight = cards.every((c, i) => i === 0 || (c.v === cards[i-1].v + 1));
        let rank = 0;
        if (isStraight && isFlush) rank = 5;
        else if (v.includes(4)) rank = 4;
        else if (v.includes(3) && v.includes(2)) rank = 3;
        else if (isFlush) rank = 2;
        else if (isStraight) rank = 1;
        if (rank > 0) return { type: 5, rank, weight: maxW };
    }
    return null;
}

function playerAction() {
    if (currentTurn !== 0) return;
    const selectedNodes = document.querySelectorAll('#hand-0 .selected');
    const selectedCards = Array.from(selectedNodes).map(n => hands[0][n.dataset.idx]);
    const p = getPattern(selectedCards);

    if (isValidMove(selectedCards, p)) {
        executeMove(0, selectedCards, p);
    } else {
        log("❌ 牌型不合或首輪需含方塊三");
    }
}

function isValidMove(cards, p) {
    if (!p) return false;
    if (isFirstTurn && !cards.some(c => c.v === 0 && c.s === 0)) return false;
    if (!lastPlay) return true;
    if (cards.length !== lastPlay.cards.length) return false;
    if (p.type === 5) {
        if (p.rank > lastPlay.pattern.rank) return true;
        if (p.rank === lastPlay.pattern.rank && p.weight > lastPlay.pattern.weight) return true;
        return false;
    }
    return p.weight > lastPlay.pattern.weight;
}

function npcTurn() {
    let hand = hands[currentTurn];
    let move = null;
    let targetLen = lastPlay ? lastPlay.cards.length : 0;
    let sizes = targetLen ? [targetLen] : [1, 2, 5];

    for (let size of sizes) {
        let combos = (size === 1) ? hand.map(c => [c]) : 
                     (size === 2) ? getPairs(hand) : getFives(hand);
        for(let c of combos) {
            let p = getPattern(c);
            if(isValidMove(c, p)) { move = {c, p}; break; }
        }
        if(move) break;
    }

    if(move) executeMove(currentTurn, move.c, move.p);
    else { log(`${names[currentTurn]} Pass`); proceedTurn(true); }
}

function getPairs(h) {
    let res = [];
    for(let i=0; i<h.length; i++) for(let j=i+1; j<h.length; j++) if(h[i].v === h[j].v) res.push([h[i], h[j]]);
    return res;
}

function getFives(h) {
    let res = [];
    for(let i=0; i<40; i++) {
        let s = [...h].sort(() => Math.random()-0.5).slice(0,5);
        if(getPattern(s)) res.push(s);
    }
    return res;
}

function executeMove(idx, cards, p) {
    lastPlay = { cards, pattern: p };
    passCount = 0; isFirstTurn = false;
    cards.forEach(c => {
        let i = hands[idx].findIndex(hc => hc.v === c.v && hc.s === c.s);
        hands[idx].splice(i, 1);
    });
    log(`${names[idx]} 出牌`);
    if (hands[idx].length === 0) {
        updateUI();
        setTimeout(() => { alert("遊戲結束！獲勝者是：" + names[idx]); initGame(); }, 500);
        return;
    }
    proceedTurn(false);
}

function proceedTurn(isPass) {
    if (isPass) passCount++;
    currentTurn = (currentTurn + 1) % 4;
    if (passCount >= 3) { lastPlay = null; passCount = 0; log("新一輪起始"); }
    updateUI();
    if (currentTurn !== 0) setTimeout(npcTurn, 1000);
}

function playerPass() { if(lastPlay && !isFirstTurn) proceedTurn(true); }

window.onload = initGame;
</script>
</body>
</html>