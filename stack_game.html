<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>辦公室疊疊樂</title>
    <style>
      body {
        margin: 0;
        background: #1a1a2e;
        overflow: hidden;
        font-family: sans-serif;
        touch-action: none; /* 重要：防止瀏覽器手勢干擾 */
        -webkit-user-select: none;
        user-select: none;
      }
      canvas { display: block; }
      #ui {
        position: absolute;
        top: 30px;
        width: 100%;
        text-align: center;
        color: #fff;
        pointer-events: none; /* 確保點擊能穿過文字 */
        z-index: 10;
      }
      #score { font-size: 70px; font-weight: 900; margin: 0; }
      #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(10, 10, 30, 0.9);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: white; z-index: 100;
      }
      button {
        padding: 15px 60px; font-size: 1.2rem; cursor: pointer;
        background: #00d2ff; border: none; border-radius: 50px;
        color: #fff; font-weight: bold; pointer-events: auto;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div id="score">0</div>
      <div id="msg">點擊畫面開始</div>
    </div>

    <div id="overlay">
      <h1>辦公室疊疊樂</h1>
      <button id="mainBtn">進入辦公室</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const msgEl = document.getElementById("msg");
      const overlay = document.getElementById("overlay");
      const mainBtn = document.getElementById("mainBtn");

      let blocks = [], debris = [];
      let gameState = "START";
      let speed = 2.5, cameraY = 0, screenShake = 0;
      let currentBlock = {};
      let perfectCount = 0;
      let lastEventTime = 0; // 防震盪鎖

      // 音效設定
      let audioCtx = null;
      function initAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === "suspended") audioCtx.resume();
      }

      function playTone(freq, type = "sine", duration = 0.1, volume = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      }

      function init() {
        initAudio();
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        blocks = [{ x: (canvas.width - 200) / 2, y: canvas.height - 150, width: 200, color: 200 }];
        debris = [];
        scoreEl.innerText = "0";
        speed = 2.5; cameraY = 0; perfectCount = 0;
        newBlock();
        gameState = "PLAYING";
        overlay.style.display = "none";
        animate();
      }

      function newBlock() {
        const last = blocks[blocks.length - 1];
        currentBlock = {
          x: 0, y: last.y - 45, width: last.width,
          direction: 1, color: 200 + ((blocks.length * 15) % 360)
        };
      }

      function animate() {
        if (gameState === "START") return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const targetCam = (blocks.length - 4) * 45;
        cameraY += (targetCam - cameraY) * 0.1;

        ctx.save();
        ctx.translate(0, cameraY);

        // 畫碎片
        debris.forEach((d, i) => {
          d.y += d.vy; d.vy += 0.6; d.opacity -= 0.03;
          ctx.fillStyle = `hsla(${d.color}, 70%, 50%, ${d.opacity})`;
          ctx.fillRect(d.x, d.y, d.width, 43);
          if (d.opacity <= 0) debris.splice(i, 1);
        });

        // 畫已疊磚塊
        blocks.forEach((b) => {
          ctx.fillStyle = `hsl(${b.color}, 70%, 60%)`;
          ctx.fillRect(b.x, b.y, b.width, 43);
          if (b.perfect) {
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 4;
            ctx.strokeRect(b.x, b.y, b.width, 43);
          }
        });

        // 畫移動磚塊
        if (gameState === "PLAYING") {
          currentBlock.x += speed * currentBlock.direction;
          if (currentBlock.x + currentBlock.width > canvas.width || currentBlock.x < 0)
            currentBlock.direction *= -1;
          ctx.fillStyle = `hsl(${currentBlock.color}, 70%, 60%)`;
          ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, 43);
        }

        ctx.restore();
        requestAnimationFrame(animate);
      }

      function handleAction(e) {
        // 防止重複觸發 (300ms 內只允許一次)
        const now = Date.now();
        if (now - lastEventTime < 300) return;
        lastEventTime = now;

        // 如果點到的是按鈕，交給按鈕自己的 onclick 處理
        if (e.target.tagName === "BUTTON") return;

        if (gameState === "PLAYING") {
          const last = blocks[blocks.length - 1];
          const diff = currentBlock.x - last.x;

          if (Math.abs(diff) >= currentBlock.width) {
            gameOver();
          } else {
            if (Math.abs(diff) < 12) {
              currentBlock.x = last.x;
              currentBlock.perfect = true;
              perfectCount++;
              playTone(400 + perfectCount * 50);
            } else {
              perfectCount = 0;
              let dWidth = Math.abs(diff);
              let dX = diff > 0 ? currentBlock.x + (currentBlock.width - diff) : currentBlock.x;
              debris.push({ x: dX, y: currentBlock.y, width: dWidth, color: currentBlock.color, vy: 2, opacity: 1 });
              
              if (diff > 0) currentBlock.width -= diff;
              else { currentBlock.width += diff; currentBlock.x = last.x; }
              playTone(200);
            }
            blocks.push({ ...currentBlock });
            scoreEl.innerText = blocks.length - 1;
            speed += 0.1;
            newBlock();
          }
        }
      }

      function gameOver() {
        gameState = "OVER";
        playTone(100, "sawtooth", 0.5);
        overlay.style.display = "flex";
        overlay.innerHTML = `<h1>得分: ${blocks.length - 1}</h1><button onclick="location.reload()">再試一次</button>`;
      }

      // 監聽按鈕點擊
      mainBtn.addEventListener("click", init);

      // 核心修正：同時監聽觸控與滑鼠，且不阻止預設行為
      window.addEventListener("touchstart", handleAction);
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) handleAction(e);
      });

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
      
      // 初始化畫布大小
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    </script>
  </body>
</html>