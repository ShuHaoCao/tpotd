<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>辦公室疊疊樂</title>
    <style>
      body {
        margin: 0; background: #1a1a2e; overflow: hidden;
        font-family: -apple-system, "PingFang TC", sans-serif;
        /* 徹底停用手勢，交給 JS 處理 */
        touch-action: none; -webkit-user-select: none; user-select: none;
      }
      canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
      #ui {
        position: absolute; top: 30px; width: 100%; text-align: center;
        color: #fff; z-index: 10; pointer-events: none;
      }
      #score { font-size: 70px; font-weight: 900; }
      #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(10, 10, 30, 0.9);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: white; z-index: 100;
      }
      button {
        padding: 15px 60px; font-size: 1.2rem; cursor: pointer;
        background: #00d2ff; border: none; border-radius: 50px;
        color: #fff; font-weight: bold; position: relative; z-index: 101;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div id="score">0</div>
      <div id="msg">點擊畫面放磚塊</div>
    </div>

    <div id="overlay">
      <h1 id="title">辦公室疊疊樂</h1>
      <p id="rank-text"></p>
      <button id="mainBtn">進入辦公室</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const overlay = document.getElementById("overlay");
      const mainBtn = document.getElementById("mainBtn");

      let blocks = [], debris = [];
      let gameState = "START";
      let speed = 2.5, cameraY = 0;
      let currentBlock = {};
      let audioCtx = null;

      // 1. 初始化畫布（手機必須先執行）
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // 2. 啟動遊戲
      function start() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") audioCtx.resume();

        blocks = [{ x: (canvas.width - 200) / 2, y: canvas.height - 150, width: 200, color: 200 }];
        debris = [];
        scoreEl.innerText = "0";
        speed = 2.5; cameraY = 0;
        newBlock();
        gameState = "PLAYING";
        overlay.style.display = "none";
        requestAnimationFrame(animate);
      }

      function newBlock() {
        const last = blocks[blocks.length - 1];
        currentBlock = {
          x: 0, y: last.y - 45, width: last.width,
          direction: 1, color: 200 + ((blocks.length * 15) % 360)
        };
      }

      function animate() {
        if (gameState !== "PLAYING" && gameState !== "OVER") return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const targetCam = (blocks.length - 4) * 45;
        cameraY += (targetCam - cameraY) * 0.1;

        ctx.save();
        ctx.translate(0, cameraY);

        // 碎片更新
        debris.forEach((d, i) => {
          d.y += d.vy; d.vy += 0.6; d.opacity -= 0.03;
          ctx.fillStyle = `hsla(${d.color}, 70%, 50%, ${d.opacity})`;
          ctx.fillRect(d.x, d.y, d.width, 43);
          if (d.opacity <= 0) debris.splice(i, 1);
        });

        // 已疊塊更新
        blocks.forEach(b => {
          ctx.fillStyle = `hsl(${b.color}, 70%, 60%)`;
          ctx.fillRect(b.x, b.y, b.width, 43);
        });

        // 移動塊更新
        if (gameState === "PLAYING") {
          currentBlock.x += speed * currentBlock.direction;
          if (currentBlock.x + currentBlock.width > canvas.width || currentBlock.x <= 0)
            currentBlock.direction *= -1;
          ctx.fillStyle = `hsl(${currentBlock.color}, 70%, 60%)`;
          ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, 43);
        }

        ctx.restore();
        requestAnimationFrame(animate);
      }

      // 3. 核心修正：使用全域監聽並過濾按鈕
      window.addEventListener("mousedown", (e) => {
          if (e.target.tagName === 'BUTTON') return;
          handleInput();
      });

      // 針對手機的特別處理：使用 click 配合 pointer-events
      window.addEventListener("touchstart", (e) => {
          if (e.target.tagName === 'BUTTON') return;
          // 防止某些手機瀏覽器雙擊縮放
          e.preventDefault(); 
          handleInput();
      }, { passive: false });

      function handleInput() {
        if (gameState === "PLAYING") {
          const last = blocks[blocks.length - 1];
          const diff = currentBlock.x - last.x;

          if (Math.abs(diff) >= currentBlock.width) {
            gameState = "OVER";
            showGameOver();
          } else {
            // 切除邏輯 (略微簡化確保性能)
            if (Math.abs(diff) > 10) {
              let dWidth = Math.abs(diff);
              let dX = diff > 0 ? currentBlock.x + (currentBlock.width - diff) : currentBlock.x;
              debris.push({ x: dX, y: currentBlock.y, width: dWidth, color: currentBlock.color, vy: 2, opacity: 1 });
              currentBlock.width -= dWidth;
              if (diff < 0) currentBlock.x = last.x;
            } else {
              currentBlock.x = last.x; // Perfect
            }
            blocks.push({ ...currentBlock });
            scoreEl.innerText = blocks.length - 1;
            speed += 0.1;
            newBlock();
          }
        }
      }

      function showGameOver() {
        const score = blocks.length - 1;
        document.getElementById("title").innerText = "遊戲結束: " + score + " 層";
        mainBtn.innerText = "再蓋一棟";
        overlay.style.display = "flex";
      }

      // 按鈕專用事件
      mainBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        if (gameState === "OVER") {
            // 遊戲結束時點擊按鈕，重新整理網頁是最保險的做法
            location.reload();
        } else {
            start();
        }
      });
    </script>
  </body>
</html>